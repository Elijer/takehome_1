<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Front End Exercise</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style type="text/css">
    html {
      margin: 0;
      padding: 0;
/*      background: linear-gradient(45deg, hsla(197, 100%, 63%, 1) 0%, hsla(294, 100%, 55%, 1) 100%);*/
    }
    body {
      margin: 0;
      padding: 10px;
    }
    #app {
      display: flex;
      flex-wrap: wrap;
/*      gap: 10px;*/
    }
    #app > div {
      --span: 1;
      aspect-ratio: var(--span) / 1;
      flex-basis: calc(calc(calc(var(--span) / 3) * 100%));
      background: hsla(197, 100%, 63%, 1);
      border: 10px solid white;
      border-radius: 15px;
      text-align: center;
      box-sizing: border-box;
      padding: 10px;
    }

    #sentry {
      height: 1px;
      width: 100%;
      background: transparent;
      margin-top: 10px;
      opacity: 0%;
    }
  </style>
  <script type="text/javascript">
/////////////////
// DO NOT EDIT //
/////////////////

const fetchData = (() => {
  const fakeData = [];
  const dataCount = Math.floor(Math.random() * 200) + 50;

  for (let i = 0; i < dataCount; i++) {
    fakeData.push({
      id: i + 1,
      span: Math.random() > 0.5 ? Math.floor(Math.random() * 3) + 1 : 1,
    });
  }

  return (startIndex, endIndex) => {
    const p = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve({
          length: fakeData.length,
          data: fakeData.slice(startIndex, endIndex),
        });
      }, 333);
    });
    return p;
  };
})();

////////////////////////
// END of DO NOT EDIT //
////////////////////////
  </script>
  </head>
  <body>
    <section id="app">
      <div v-for="d in sortedData" :style="{ '--span': d.span }" :key="d.id">{{ d.id }}</div>
    </section>
    <script type="text/javascript">
const { createApp, ref, computed, onMounted } = Vue;

createApp({
  setup() {

    const BUFFER_THRESHHOLD = 0.5;
    const columns = 3;
    const pageSize = 10;
    const lastFetchedIndex = ref(0);
    const isLoading = ref(false);
    const data = ref({ length: 0, data: [] });

    async function getNextPage(){
      const d = await fetchData(
          lastFetchedIndex.value,
          lastFetchedIndex.value + pageSize
        );
        console.log(d.length)
        lastFetchedIndex.value = lastFetchedIndex.value + d.data.length;
        data.value = { length: d.length, data: [...data.value.data, ...d.data] };
    }

    function rowSummer(row){
      return row.reduce((sum, brick) => sum + brick.span, 0);
    }

    const sortedData = computed(() => {
      console.time("start")
      let s = [...data.value.data];
      let result = [];
      let pendingRows = [];

      outer: for (let i = 0; i < s.length; i++) {
        let brick = s[i];

        // Handle full-width blocks immediately
        if (brick.span === columns) {
          result.push(brick);
          continue;
        }

        // Try to fit into existing pending rows
        let fitted = false;
        for (let j = 0; j < pendingRows.length; j++) {
          let row = pendingRows[j];
          let rowSum = rowSummer(row);
          
          // If this brick fits in this row
          if (rowSum + brick.span <= columns) {
            row.push(brick);
            
            // If row is now full, move it to result
            if (rowSum + brick.span === columns) {
              result.push(...row);
              pendingRows.splice(j, 1);
            }
            
            fitted = true;
            break;
          }
        }

        // If didn't fit in any existing row, start new row
        if (!fitted) {
          pendingRows.push([brick]);
        }
      }

      // Add any remaining pending rows to result
      for (let row of pendingRows) {
        result.push(...row);
      }

      console.timeEnd("start")
      return result;
      });

    function createObserver() {
      let observer;
      
      const options = {
        rootMargin: "0px",
        threshold: .1,
      };

      observer = new IntersectionObserver(async function(entries){
        if (entries[0].isIntersecting) getNextPage()
      }, options);
      observer.observe(document.querySelector("#sentry"));
    }

    function resetSentryLocation(){
        const sentry = document.createElement("div")
        sentry.id = "sentry"
        const app = document.getElementById("app")
        app.appendChild(sentry)
      }
    
    onMounted(async() => {
      await getNextPage()
      resetSentryLocation()
      createObserver()
    });
    return {
      data,
      sortedData,
      lastFetchedIndex,
      // handleIntersect
    };
  },
}).mount('#app');
      </script>
  </body>
</html>
